<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Maze Gen</title>

    <!-- import the webpage's stylesheet -->
    <link rel="stylesheet" href="/CSSsubpages/mazegen.css" />

    <!-- import the webpage's javascript file -->
    <script src="/script.js" defer></script>
  </head>
  <body>
    <h1>
      Maze Gen  <a href="/DFSsubpage/home.html">
           <button id="homebutton">Go Back</button>
       </a>
    </h1>
       <button id="mazegenbutton">New Maze</button>
    <h2>
       <button id="easybutton">Easy</button>
       <button id="medbutton">Medium</button>
       <button id="hardbutton">Hard</button>
    </h2>
    <script
      src="https://cdn.glitch.com/7616735a-c9d7-4c9d-9178-8489a3306d8c%2Fp5.js?v=1609031588731"
      defer
    ></script>
    <script>
      class Cell {
        constructor(xx, yy) {
          this.x = xx;
          this.y = yy;
          this.cellrow = this.x / celllength;
          this.cellcol = this.y / celllength;
          this.northwall = true;
          this.southwall = true;
          this.westwall = true;
          this.eastwall = true;
          this.visited = false;
          this.unvisitedneighbors = true;
          this.dice = [];
        }

        update() {
          if (this.visited) {
            noStroke();
            fill(c);
            rect(this.x, this.y, celllength, celllength);
          }
        }

        show() {
          stroke(255);
          strokeWeight(4);
          if (this.northwall == true) {
            line(this.x, this.y, this.x + celllength, this.y);
          }
          if (this.eastwall == true) {
            line(
              this.x + celllength,
              this.y,
              this.x + celllength,
              this.y + celllength
            );
          }
          if (this.southwall == true) {
            line(
              this.x,
              this.y + celllength,
              this.x + celllength,
              this.y + celllength
            );
          }
          if (this.westwall == true) {
            line(this.x, this.y, this.x, this.y + celllength);
          }
        }

        getNeighbors() {
          this.dice = [];
          //check not next to north boundary
          if (dist(this.x, this.y, this.x, 0) > 0) {
            //check north cell to see if visited
            if (cell[this.cellrow][this.cellcol - 1].visited == false) {
              this.dice.push("North");
            }
          }

          //check not next to east boundary
          if (dist(this.x, this.y, col * celllength, this.y) > celllength) {
            //check east neighbor
            if (cell[this.cellrow + 1][this.cellcol].visited == false) {
              this.dice.push("East");
            }
          }

          //check not next to west boundary
          if (dist(this.x, this.y, 0, this.y) > 0) {
            //check west neighbor
            if (cell[this.cellrow - 1][this.cellcol].visited == false) {
              this.dice.push("West");
            }
          }

          //check not next to south boundary
          if (dist(this.x, this.y, this.x, row * celllength) > celllength) {
            //check south neighbor
            if (cell[this.cellrow][this.cellcol + 1].visited == false) {
              this.dice.push("South");
            }
          }

          this.checkNeighbors();

          if (this.unvisitedneighbors) {
            let randomindex = floor(random(0, this.dice.length));
            if (this.dice[randomindex] == "North") {
              return this.removeNorthWall();
            } else if (this.dice[randomindex] == "East") {
              return this.removeEastWall();
            } else if (this.dice[randomindex] == "West") {
              return this.removeWestWall();
            } else if (this.dice[randomindex] == "South") {
              return this.removeSouthWall();
            } else {
              return null;
            }
          } else {
            return null;
          }
        }

        removeNorthWall() {
          this.northwall = false;
          cell[this.cellrow][this.cellcol - 1].southwall = false;
          return cell[this.cellrow][this.cellcol - 1];
        }

        removeEastWall() {
          this.eastwall = false;
          cell[this.cellrow + 1][this.cellcol].westwall = false;
          return cell[this.cellrow + 1][this.cellcol];
        }

        removeWestWall() {
          this.westwall = false;
          cell[this.cellrow - 1][this.cellcol].eastwall = false;
          return cell[this.cellrow - 1][this.cellcol];
        }

        removeSouthWall() {
          this.southwall = false;
          cell[this.cellrow][this.cellcol + 1].northwall = false;
          return cell[this.cellrow][this.cellcol + 1];
        }

        checkNeighbors() {
          if (dist(this.x, this.y, this.x, 0) > 0) {
            //check north cell to see if visited
            if (cell[this.cellrow][this.cellcol - 1].visited == false) {
              this.unvisitedneighbors = true;
              return;
            } else {
              this.unvisitedneighbors = false;
            }
          }

          //check not next to east boundary
          if (dist(this.x, this.y, col * celllength, this.y) > celllength) {
            //check east neighbor
            if (cell[this.cellrow + 1][this.cellcol].visited == false) {
              this.unvisitedneighbors = true;
              return;
            } else {
              this.unvisitedneighbors = false;
            }
          }

          //check not next to west boundary
          if (dist(this.x, this.y, 0, this.y) > 0) {
            //check west neighbor
            if (cell[this.cellrow - 1][this.cellcol].visited == false) {
              this.unvisitedneighbors = true;
              return;
            } else {
              this.unvisitedneighbors = false;
            }
          }

          if (dist(this.x, this.y, this.x, row * celllength) > celllength) {
            //check south neighbor
            if (cell[this.cellrow][this.cellcol + 1].visited == false) {
              this.unvisitedneighbors = true;
              return;
            } else {
              this.unvisitedneighbors = false;
            }
          }
        }
      }

      let col;
      let row;
      var c;
      var cell = [];
      var stack = [];
      let celllength;
      let button;
      let easybutton, medbutton, hardbutton;

      function setup() {
         cvn = createCanvas(roundbyhundred(windowWidth-72), roundbyhundred(windowHeight-200));
        cvn.position((windowWidth-width)/2, 200);
        button = select("#mazegenbutton");
        easybutton = select("#easybutton");
        medbutton = select("#medbutton");
        hardbutton = select("#hardbutton");
        NewMaze(100);
      }
      
      function roundbyhundred(n) {
        return 100 * Math.floor((n + 50) / 100);
      }

      function draw() {
        background(220);
        button.mouseClicked(buttonPressed);
        easybutton.mouseClicked(easy);
        medbutton.mouseClicked(med);
        hardbutton.mouseClicked(hard);
        for (let i = 0; i < col; i++) {
          for (let j = 0; j < row; j++) {
            cell[i][j].show();
            cell[i][j].update();
          }
        }
      }
      
      function buttonPressed() {
        NewMaze(celllength);
      }
      
      function easy() {
        celllength = 100;
        NewMaze(celllength);
      }
      
      function med() {
        celllength = 50;
        NewMaze(celllength);
      }
      
       function hard() {
        celllength = 25;
        NewMaze(celllength);
      }

      function DFS(current) {
        current.visited = true;
        while (current.unvisitedneighbors) {
          stack.push(current);
          next = current.getNeighbors();
          if (next != null) {
            DFS(next);
          } else if (stack.length > 0) {
            stack.splice(stack.length - 1, 1);
            DFS(stack[stack.length - 1]);
          }
          current.checkNeighbors();
        }
      }

      function NewMaze(cellwidth) {
        celllength = cellwidth;
        c = color(random(0,255), random(0,255), random(0,255));
        col = width/ celllength;
        row = height / celllength;
        cell = [];
        stack = [];
        for (let i = 0; i < col; i++) {
          cell[i] = [];
          for (let j = 0; j < row; j++) {
            cell[i][j] = new Cell((i * width) / col, (j *height) / row);
          }
        }
        DFS(cell[0][0]);
      }
    </script>
  </body>
</html>
